# This file converts segment files generated by PICNIC into BED files.
# IT ALSO LIFTS THEM TO HG19, using the results of a call to liftOver.

import os
import argparse
fn_dictionary = '/notebook/code/src/human_lines_database/cell_line_attributes/cell_line_dictionary.txt'

#dir_segments = '/Volumes/2014_backup/datasets/human_lines_ccle/CN/segments'
#dir_bed = '/datasets/human_lines_ccle/CN/segment_beds'
parser = argparse.ArgumentParser(description='Convert segments to bed')
parser.add_argument('dir_segments', help='input segment file directory')
parser.add_argument('dir_output', help='output BED directory')
args = parser.parse_args()

dir_segments = args.dir_segments
dir_bed = args.dir_output

# following code lifts over old segment locations to new hg19
fn_pos_old = '/datasets/human_lines_CCLE/CN/PICNIC/annotation/Snp6FeatureMappings.csv'
fn_pos_new = '/datasets/human_lines_CCLE/CN/PICNIC/annotation/hg19_SNP6_liftover_results.bed'
fn_pos_new_best_guesses = '/datasets/human_lines_CCLE/CN/PICNIC/annotation/hg19_SNP6_liftover_best_fits_for_deleted_loci.bed'
f = open(fn_pos_old)
id2pos = {}
for line in f:
    a = line.rstrip('\r\n').split(',')
    id2pos[ a[0] ] = [ a[1], a[2], "" ]

f.close()
f = open(fn_pos_new)
for line in f:
    a = line.rstrip('\r\n').split('\t')
    id2pos[ a[3] ][2] = a[2]

f.close()
f = open(fn_pos_new_best_guesses)
for line in f:
    a = line.rstrip('\r\n').split('\t')
    id2pos[ a[3] ][2] = a[2]

f.close()
idtrans = {}
for key in id2pos.keys():
    chrom, oldpos, newpos = id2pos[key]
    if chrom=="X":
        chrom="23"
    
    if chrom=="Y":
        chrom="24"
    
    idtrans[ chrom + "_" + oldpos ] = newpos

f = open(fn_dictionary)
a = f.readline().rstrip('\r\n').split('\t')
idx_ccle = a.index("id_ccle_snp")
CEL2id = {}
for line in f:
    a = line.rstrip('\r\n').split('\t')
    if a[idx_ccle] != "NA":
        CEL2id[ a[idx_ccle] ] = a[0]

f.close()

fn_segments = os.listdir(dir_segments)
if ".DS_Store" in fn_segments:
    fn_segments.remove(".DS_Store")

n_found = 0

# The code looking at the previous chromosome and loc begin/end is there to catch the 
# odd case where two adjacent segments have the same starting point but different end 
# points. This shouldn't happen, but in at least one case (CMK-86 on chr15) it does
for fn_segment in fn_segments:
    CEL = fn_segment.replace("_feature.TXT","")
    if CEL in CEL2id:
        n_found += 1
        id = CEL2id[CEL]
        f = open(dir_segments + '/' + fn_segment)
        fo = open(dir_bed + '/' + id + '___segments_PICNIC_max8.BED', 'w')
        fo.write( "# " + fn_segment + '\n')
        previous_chrom, previous_loc_begin, previous_loc_end = "", "", ""
        for line in f:
            #1,1,2513,1,51599,5490952,1,2
            seg = line.rstrip('\r\n').split(',')
            chrom, loc_begin, loc_end = seg[3], seg[4], seg[5]
            loc_begin = idtrans[ chrom + "_" + loc_begin ]
            loc_end = idtrans[ chrom + "_" + loc_end ]
            if chrom==previous_chrom and (loc_begin==previous_loc_begin or loc_end==previous_loc_end):
                pass # this is a duplicate start or end
            else:
                if loc_begin != "" and loc_end != "":
                    if int(loc_begin) < int(loc_end):
                        fo.write( chrom + '\t' + loc_begin + '\t' + loc_end + '\t' )
                        fo.write( 'id:' + id + ',minor:' + seg[6] + ',major:' + seg[7] + '\n' )
            previous_chrom, previous_loc_begin, previous_loc_end = chrom, loc_begin, loc_end
                
        fo.close()
